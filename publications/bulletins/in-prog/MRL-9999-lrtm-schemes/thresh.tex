\documentclass{mrl}
\usepackage{enumerate}
\usepackage{todo}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{defn}[theorem]{Definition}
\newtheorem{disc}[theorem]{Remark}



\title{Ring Threshold Multisignature Schemes and Security Models}
\authors{Brandon Goodell\footnote{\texttt{surae.noether@protonmail.com}} and Sarang Noether\footnote{\texttt{sarang.noether@protonmail.com}}}
\affiliations{Monero Research Lab}
\date{\today}

\type{RESEARCH BULLETIN}
\ident{MRL-XXXX}

\begin{document}

% Title area
%\hfill\includegraphics[width=100px]{logo.png}
%\newline
%\noindent\colorbox{bloo}{\parbox{\textwidth}{{\sffamily\color{white}RESEARCH BULLETIN \hfill MRL-9999a}}}
%\vskip 10pt
%\noindent{\Large Ring Threshold Multisignature Schemes and Security Models}
%\vskip 5pt
%\noindent{Brandon Goodell\footnote{\texttt{surae.noether@protonmail.com}} and Sarang Noether}
%\newline
%\noindent{Monero Research Lab}
%\newline
%\noindent{\today}

%\begin{frontmatter}
%\begin{abstractbox}
\begin{abstract}
This research bulletin extends \cite{noether2016ring} by constructing a $t$-of-$n$ threshold multi-layered linkable spontaneous anonymous group signature scheme ($t$-of-$n$ MLSAG) in the same style as the LSAG schemes put forth by \cite{liu2004linkable}. %We present security models for this scheme, present security proofs in those models, describe an implementation, and explain some use-cases for the scheme in cryptocurrencies.
\end{abstract}
%\end{abstractbox}
%\end{frontmatter}


\section{Introduction and Background}

Ring signatures can play a critical role in promoting user anonymity (or at least user ambiguity) during message authentication. A one-time signature scheme inserts a barrier between user key pairs and one-time signature key pairs. Due to this utility, one-time ring signature schemes enjoy application in many cryptocurrency protocols. Multisignatures play a critical role in off-chain transactions for cryptocurrencies (e.g.\ the Bitcoin Lightning Network) and for message authentication in general (e.g.\ multi-factor authentication). A $t$-of-$N$ threshold multisignature scheme specifies sets containing $N$ public keys and thresholds $t$ such that any subset with at least $t$ elements may collaborate to fashion a signature. A usual digital signature scheme is a $1$-of-$1$ multisignature scheme, so we can regard all keys as shared public keys (just perhaps with a coalition of only one member). It is therefore natural to extend the notion of ring signatures to ring threshold multisignatures for implementation in cryptocurrencies to enjoy signer-ambiguous multisignatures. 

A multisignature scheme is a $t$-of-$N$ \textit{ring threshold multisignature} (RTM) scheme if any set of $N$ keys may be specified as a coalition of signers and assigned a shared public key $X_{\texttt{shared}}$ such that any $t$ coalition members may collaborate to fashion a ring signature. The ring of signatories $R$  contains the key $X_{\texttt{shared}}$, but an adversary cannot determine which element of $R$ computed the signature. 

If the number of users cooperating in the construction of a signature is not secret, naive multisignature schemes can be constructed from any signature scheme (ring signature or otherwise) by simply requiring each participating user to present a separate signature. More sophisticated implementations combine these together using boolean AND circuits as in the Borromean ring set-up described in \cite{} for efficiency reasons. 

If a user does not desire to reveal to an adversary how many devices were used for some multi-factor authentication, it should be difficult for an adversary to determine the size of a coalition behind some shared public key. This property should be satisfied even if the adversary can persuade the party (or parties) controlling the shared public key to sign arbitrary messages chosen by the adversary. We introduce the security definition of \textit{coalition-indistinguishable} multisignature schemes against adaptive chosen message attacks: given a shared $t$-of-$N$ public key $X_{\texttt{shared}}$, an adversary should be unable to guess any information about $t$ or $N$. %This property cannot be satisfied if the adversary has corrupted any public key in the coalition. If some coalition member for $X$, say $X^{\prime}$, is a shared $t^{\prime}$-of-$N^{\prime}$ public key, this means that if the adversary has corrupted $t^{\prime}$ or more members of the coalition for $X^{\prime}$, then coalition-indistinguishability is impossible. Thus we investigate the notion of \textit{subthreshold corruption oracle access}.

%Moreover, for multifactor authentication purposes, $(N-1)$-of-$N$ and $N$-of-$N$ schemes are of particular interest. Due to this, we consider only $t$-of-$N$ threshold ring signatures with $N-1 \leq t \leq N$, with $t > 1$, and with $N > 1$.



\subsection{Our Contribution}

We consider a formal definition of one-time linkable ring threshold multisignature (OT-LRTM) schemes. We investigate modifications to security definitions that take threshold behaviors into account and a new security model. We describe a modified implementation of $t$-of-$N$ linkable ring threshold multisignature (under the restriction $N-1 \leq t \leq N$) first described by previous MRL contributors Shen Noether in \cite{noether2016ring} and implemented for use in Monero by contributor \texttt{Luigi}, and we prove that this implementation satisfies our security definitions.


\subsection{Notation and Prerequisites}

We let $\mathbb{G}$ be a group with prime order $\mathfrak{q}$ and we let $G$ denote a commonly known point with order $\mathfrak{q}$. Denote the user and transaction key spaces, respectively, as $\mathcal{K}_{\texttt{user}}, \mathcal{K}_{\texttt{txn}}$. In implementations involving cryptocurrencies, there exists a function $\texttt{dest}:\mathcal{K}_{\texttt{txn}} \to \mathcal{K}_{\texttt{user}}$ describing the user key pair to whom a certain transaction key pair is addressed. For any transaction key pair $(q,Q) \in \mathcal{K}_{\texttt{txn}}$, we say $\texttt{dest}(q,Q)$ is the \textit{destination} user key pair for $(q,Q)$. We sometimes write $Q$ as $Q_X$ to emphasize the destination user key $X$ associated with the transaction key $Q$.
%We denote the message space $\mathcal{M}=\left\{0,1\right\}^*$. We let $\mathbb{G}$ be an additive group with prime order $q$ an an arbitrary generator $G$. We denote $H_{\mathcal{X},\mathcal{Y}}(-)$ as a cryptographic hash function from the space $\mathcal{X}$ to $\mathcal{Y}$. For example $H_{\mathbb{G},\mathbb{Z}_q}(-)$ is a cryptographic point-to-scalar function. We assume that any two hash functions $H_{\mathcal{X},\mathcal{Y}}(-)$ and $H_{\mathcal{X}^{\prime},\mathcal{Y}^{\prime}}(-)$ are statistically independent.


\section{MLSAG and Straightforward Threshold Set-ups}


We briefly describe LSAG ring signatures in the sense of \cite{liu2004linkable} and their MLSAG variant used in Monero, and then a straightforward implementation of an LRTM scheme. 

\subsection{MLSAGs}

A user with user key pair $(y,Y)$ wishes to spend an old transaction output with private-public transaction key pair $(q,Q) \in \mathcal{K}_{\texttt{txn}}$ such that $\texttt{dest}(q,Q) = (y,Y)$. The user constructs an appropriate message $M$, a destination user key $X$, computes the key image $J = qH_p(Q)$, and selects a ring of public transaction keys $R=\left\{Q_1, \ldots Q_L\right\}$ such that, for a secret distinguished index $k$, $Q_{k}=Q$. For each $i=1,\ldots,L$, the signer computes an elliptic curve point from the $i^{th}$ ring member public key  as $H_i := H_{p}(Q_i)$. The signer selects a random secret scalar $u$, computes an initial temporary pair of points $uG$ and $uH_{k}$, and computes an initial commitment $c_{k+1} := H_{p}(M,uG, uH_k)$. 

The signer sequentially proceeds through indices $i=k+1, k+2, \ldots, n, 1, 2, \ldots, k-1$ in the following way. The signer selects a random scalar $s_i$, computes the next temporary pair of points $s_iG + c_i Q_i$ and $s_i H_i + c_i J$, and computes the next commitment $c_{i+1}:=H_{p}(m,s_i G + c_i Q_i, s_i H_i + c_i J)$. The signer continues proceeding through the set of keys until commitments $c_i$ have been computed for each $i=1, \ldots, L$. The signer then computes $s_{k}:=u - c_{k}q_{k}$ and publishes the signature $\sigma=(c_1, s_1, \ldots, s_n)$ and the key image $J$ in a signature-tag pair $(\sigma, J)$.

A signature-tag pair $(\sigma^*, J^*)$ on $m$ can be verified to have been generated by at least one ring member in the following way: for each $i=1,2,\ldots, L$, the verifier computes $z_{i} = s_i^* G + c_i^* Q_i$ and $z_{i}^{\prime} = s_i^* H_i + c_i^* J^*$ and uses these to compute the $(i+1)^{th}$ commitment $c_{i+1} = H_{p}(m, z_i, z^{\prime}_i)$. After computing $c_2, c_3, \ldots, c_L, c_1$, the verifier approves of the signature if and only if $c_1 = c_1^*$. A verifier can check against double spends by comparing the key images of two signature-tag pairs.

\begin{disc}
The MLSAG generalization, where transaction keys are represented by vectors, is straightforward. With transaction keys $\underline{q}=(q_1,\ldots,q_w)$, each component of $\underline{q}$ is used to generate a temporary pair of points starting with $u_jG$, $u_j H_k$ and then $s_{j,i} G + c_{i} Q_{j,i}$, $s_{j,i} H_{j,i} + c_{i} J$, providing the associated commitments
\[c_{i+1}:=H_{p}\left(m,\left\{(s_{j,i} G + c_i Q_{j,i}, s_{j,i} H_{j,i} + c_i J)\right\}_{j=1}^{w}\right).\]
\end{disc}


\begin{disc}
Note that user keys are not used above except as a destination for the transaction key. Anyone with a destination public user key in mind and knowledge of a transaction private key may fashion a signature like the one above. In the reference CryptoNote protocol, the private transaction key $q$ associated to some public transaction key $Q$ is only feasibly computable by a user who knows the private destination user key in $\texttt{dest}(q,Q)$ or by an adversary who can solve the discrete logarithm problem.
\end{disc}

\subsection{Extending to Threshold Signatures} \label{naiveImplement}

Note that a $1$-of-$N$ threshold signature scheme may be accomplished by simply handing out an identical set of keys to $N$ individuals: whoever decides to use them first will be able to fashion a signature. We consider this a degenerate case. On the other hand, a $1$-of-$1$ signature scheme is a usual signature scheme, as we mentioned. 

Generally, we wish to allow a coalition of (distinct) public user keys $C=\left\{X_{1}, X_{2}, \ldots, X_{N}\right\} \subseteq \mathcal{K}_{\texttt{user}}$ (where each $X_i = x_iG$) to collaboratively fashion a shared public user key $X_{\texttt{shared}}$ such that, for any transaction key pair $(q,Q) \in \mathcal{K}_{\texttt{txn}}$ such that $\texttt{dest}(q,Q) = X_{\texttt{shared}}$, any subset of at least $t$ of the users in $C$ can collaborate to fashion a signature on a message $M$ corresponding to public transaction key $Q$. Certainly we wish that no member of $C$ reveal their own private user key $x_i$, but moreover we wish that coalition members cannot feasibly learn the private transaction key $q$. 

In the $N$-of-$N$ case, we may use CryptoNote-styled user and transaction keys to see an example implementation. For this example, we assume user private-public key pairs $(x,X)$ take the form $x=(a,b)$ for some scalars $a$, $b$ and $X=(A,B)$ where $A=aG$ and $B=bG$ for some common point $G$. The private-public transaction key pair $(q,Q)$ takes the form $Q=(S,P)$, $q=(s,p)$ where $s$ is a scalar, $S=sG$, $p=H_s(aR)+b$, and $P=pG$. Given message $M$, a coalition of user keys $C$, the coalition members compute their shared public key as $X_{\texttt{shared}} := \sum_{j=1}^{N} X_j$, which is published. Assume $(q,Q)=((s,p),(S,P))$ is a transaction key pair such that $\texttt{dest}(q,Q) = X_{\texttt{shared}}$.

The coalition $C$ selects a ring of public transaction keys $\mathcal{R} = \left\{Q_1, Q_2, \ldots, Q_L\right\}$ such that $Q = Q_{k}$ for some secret index $k$.  For each $j=1, \ldots, N$, the $j^{th}$ coalition member in $C$ computes a partial key image $J_j = (H_s(a_j S) + b_j)\cdot H_p(Q)$, picks a random secret scalar $u_j$, and computes $H_i = H_{p}(Q_i)$ for each $Q_i \in R$. The coalition $C$ computes the key image $J = \sum_j J_j$, the random points $u_{k} G = \sum_j u_{j} G$, and $u_{k} H_{k}= \sum_j u_{j} H_{k}$. The coalition $C$ decides upon random values $s_{k+1}, \ldots, s_{L}, s_1, \ldots, s_{k-1}$. Using these, any member in $C$ may compute the commitments 
\begin{align*}
c_{k+1} :=& H_{p}(m,  u_k G, u_k H_k) \text{ and}\\
c_{i+1} :=& H_{p}(m,  s_{i} G + c_i P_i, s_{i} H_i + c_i J)\text{ for }i=k+1, \ldots, k-1.
\end{align*}
All coalition members then use $c_k$ to compute their personal $s_{k,j} = u_j - c_{k} (H_s(a_j S) + b_j)$. The signers share their $s_{k,j}$ with the other signers. Any threshold member may then compute the value $s_{k} = \sum_j s_{k,j}$ and publish the signature-tag pair $(\sigma, J)$ where $\sigma = (c_1, s_1, \ldots, s_L)$ as usual. Any user may verify this signature corresponds to the $N$-of-$N$ shared public key $X_{\texttt{shared}}$ using the same method as above.


This implementation satisfies our immediate two properties: members in $C$ do not learn the private transaction key $q=\sum_j H_s(a_j S) + b_j$ and do not reveal their own private keys. Assuming at least one contributing user key in $C$ was honestly generated from a uniform random scalar, an adversary who has learned a public threshold address cannot determine the number of summands contributing to it, let alone determine the summands.  

This set-up extends naturally to an $(N-1)$-of-$N$ set-up. As before, a set of $N$ public keys $\left\{X_{1}, X_{2}, \ldots, X_{N}\right\}$ form a coalition. Each pair of users has a shared secret scalar $z_{i,j} = H_{s}(x_i X_j)$ with associated point $Z_{ij} = z_{i,j}G$. There are $\frac{N(N-1)}{2}$ such pairs; if any $N-1$ members get together, all of the associated shared secrets are known. Hence, we may simply instantiate the $(N-1)$-of-$N$ threshold as an $N^*$-of-$N^*$ set-up with $N^* = \frac{N(N-1)}{2}$. All values $Z_{i,j}$ are necessary to compute the shared public user key, $Z_{\texttt{shared}}$ and all values of $z_{i,j}$ are necessary to fashion a signature with a public transaction key $Q$ with $\texttt{dest}(Q)=Z_{\texttt{shared}}$.

%Coalition members certainly do not want to reveal their secret keys during participation, but dually, coalitions may not want the fact that an address has been collaboratively fashioned to be publicized. We should prefer, then, that implementations produce keys and signatures that are indistinguishable by an adversary from a usual signature scheme. We discuss this in more detail later.
\begin{disc}\label{remark:recursion}
Note that the above extension works for coalitions containing $t$-of-$N$ keys also. For example, when the $j^{th}$ coalition member computes the partial key image $J_j$, if this coalition member is some sub-coalition, then each member of the sub-coalition can compute their own partial key image $J_{j,k}$ and the sub-coalition can report the sum $J_j = \sum_k J_{j,k}$. In this manner, signatures involving nested coalitions may be executed recursively. We elaborate on this in Section \ref{sec:otlrtm}.
\end{disc}

\begin{disc}\label{hashed-keys}
Note that an adversary with knowledge of some set of public keys can compute the sums of all subsets to brute-force test whether a certain user key $X$ is a threshold key. Using hash functions and encrypt-then-authenticate communication, we may resolve the brute force problem. 

Consider modifying the $N$-of-$N$ implementation by having coalition members select secret scalars $\mu_j$ associated with the threshold $t$ and coalition $C$, e.g.:
\[\mu_j = H_s(\text{``multisig constant for escrow at local coffee shop''}, \texttt{secret salt})\] 
Now merely require that participating members not use their private user keys in the construction of their shared user key pair, but instead the $i^{th}$ coalition member selects a constant $\mu_i$ associated with their coalition and instead uses $x^*_i = H(x_i, \mu_i)$ as their private key (or in the $(N-1)$-of-$N$ case, computing $z^*_{i,j} = H_s(x_i^* X_j^*)$ instead of $z_{i,j} = H_s(x_i X_j)$ and communicating the points $Z^*_{i,j}$ to the coalition).

With this modification, an adversary cannot use strictly public information to determine if a certain key is a threshold key or not. The possibility remains that the adversary may overhear the associated public points $X^*_i$ (or $Z^*_{i,j}$) being communicated within the coalition, allowing the adversary to fall back on the brute force approach again. Hence, the points $X^*_i$ (or $Z^*_{i,j}$) should be communicated with a secure encrypt-then-authenticate scheme. Note that either step alone (hashing, then encrypt-then-authenticating) is insufficient to prevent the adversary from using brute force.
\end{disc}


\section{Security Models}

%In this section we present definitions we use later on. Any signature scheme requires unforgeability. Moreover, a ring signature scheme requires signature ambiguity. In a threshold multisignature scheme, coalitions of users collaborate to generate new threshold keys from sets of old keys and to generate signatures on messages using those threshold keys. A linkable signature

\subsection{One-Time Linkable Ring Threshold Multisignatures}\label{sec:otlrtm}

We begin by defining a one-time linkable ring threshold multisignature (OT-LRTM) scheme. A central idea to our security models is that a coalition of user keys may be merged into a new user key, which may then be again merged with other user keys. 


\begin{defn}{[One-Time Linkable Ring Threshold Multisignature Scheme]}\label{OT-LRTM} A one-time linkable ring threshold multisignature scheme is a set of PPT algorithms, (\texttt{UserKeyGen}, \texttt{TxnKeyGen}, \texttt{Merge},\texttt{Sign},\texttt{Verify}, \texttt{Link}) that, respectively, generates usual private-public keypairs for users, generates public transaction keys, merges user keys into new shared user keys, fashions signatures on messages given a ring of public transaction keys, verifies signatures, and links signatures. Formally:
\begin{enumerate}[(i)]
    \item $\texttt{UserKeyGen}(1^\lambda)$ outputs a random user key pair $(x,X)$ called a \textit{$1$-of-$1$ user key pair} where $x$ is a private user key with associated public user key $X$.
    
    \item $\texttt{Merge}(t,C)$ takes as input a positive integer (threshold) $t$ and coalition of private-public user keypairs $C=\left\{(x_1,X_1), (x_2,X_2), \ldots, (x_n,X_N)\right\}$ and outputs a public user key $X_{t,C}$ called a \textit{$t$-of-$N$ user key pair} or a \textit{shared user key pair}.
    
    \item $\texttt{TxnKeyGen}(1^\lambda, X)$ takes as input a public user key $X$ called the \textit{destination key}. A one-time random private-public transaction key pair $(q_X,Q_X)$ is generated. $\texttt{TxnKeyGen}$ outputs $Q_X$.
    
    \item $\texttt{ImageGen}(1^\lambda, Q, y)$ takes as input a public transaction key $Q$ with a set of private user keys $y = \left\{x_1, \ldots\right\}$ and outputs a point $J_Q$ called the \textit{key image} for the private transaction key $q$ and outputs $J_Q$.
    
    \item $\texttt{Sign}(M,X,R,k, y)$ takes as input message $M$, a destination user key $X$, ring of public transaction keys $R=\left\{Q_1, \ldots, Q_L\right\}$, secret index $k$, and a set of private user keys $y$.  $\texttt{Sign}$ obtains $Q \leftarrow \texttt{TxnKeyGen}(1^\lambda, X)$, $J \leftarrow \texttt{ImageGen}(1^\lambda, Q, y)$.  $\texttt{Sign}$ generates a signature $\sigma$ and publishes the signature-image pair $(\sigma, J)$.
    
    \item $\texttt{Verify}(M,R,\sigma)$ takes as input a message $M$, a ring of public transaction keys $R$, and a signature $\sigma$, and outputs a bit $b \in \left\{0,1\right\}$. 
    
    \item $\texttt{Link}((M_0,R_0,(\sigma_0, J_0)), (M_1,R_1,(\sigma_1, J_1)))$ takes as input two (possibly distinct) messages, two (possibly distinct) rings of transaction public keys, and two signature-image pairs. $\texttt{Link}$ outputs a bit $b \in \left\{0,1\right\}$.
\end{enumerate}
\end{defn}

 Note that a $1$-of-$1$ user key may be regarded as a ``usual'' user key in a one-time linkable ring signature scheme. In this way, we may regard all user keys as $t$-of-$N$ shared user keys by simply regarding $1$-of-$1$ keys as having a coalition of a single member. We consider only \textit{restricted} OT-LRTM schemes where $\texttt{Merge}$ is modified such that (i) if $t=1$ and $\left|C\right| = 1$, then $\texttt{Merge}$ returns the public user key in $C$, (ii) if the inequalities $2 \leq N-1 \leq t \leq N$ do not hold then $\texttt{Merge}$ outputs $\bot$ instead of a key.

\begin{defn}
Assume for each $i=0,1$, $M_i$ is an arbitrary message, $X_i$ is an arbitrary $t_i$-of-$N_i$ shared public user key with coalition $C_i$, $R_i=\left\{Q_{i,j}\right\}_{j=1}^{\left|R_i\right|}$ is an arbitrary ring of public transaction keys with associated secret indices $k_i$ such that $\texttt{dest}(Q_{i,k_i}) = X_i$, each $y_i$ is a set of private user keys such that $y_i \subseteq C_i$ and $t_i \leq \left|y_i\right|$, and each signature-tag pair $(\sigma_i, J_i)$ is honestly generated as $(\sigma_i, J_i) \leftarrow \texttt{Sign}(M_i,X_i,R_i,k_i,y_i)$. We say an OT-LRTM scheme is \textit{complete} if
\begin{enumerate}[(a)]
\item $\texttt{VER}(M_i,R_i,(\sigma_i,J_i)) = 1$ and
\item if $Q_{i,k_i} = Q_{j,k_j}$ then $\texttt{LNK}((\sigma_i, J_i), (\sigma_j, J_j))=1$.
\end{enumerate}
\end{defn}



Recall Remark \ref{hashed-keys} and consider the hash-then-encrypt-then-authenticate approach to computing shared public keys. We let $\Pi = (\texttt{UserKeyGen}^*,\texttt{Enc}^*, \texttt{Auth}^*, \texttt{Ver}^*, \texttt{Dec}^*)$ be a secure encrypt-then-authenticate scheme (where $\Pi_{\texttt{enc}} = (\texttt{Gen}^*,\texttt{Enc}^*, \texttt{Dec}^*)$ is a secure encryption sub-scheme and $\Pi_{\texttt{auth}} = (\texttt{Gen}^*,\texttt{Auth}^*, \texttt{Ver}^*)$ is a secure message authentication sub-scheme). Augmenting the implementation of Section \ref{naiveImplement} with $\Pi$ allows the coalition for $X_{\texttt{shared}}$ to compute the appropriate values to participate in the signing of a message in a recursive fashion. To see how, note that when the implementation of Section \ref{naiveImplement} is carried out, this $t$-of-$N$ shared public user key $X_{\texttt{shared}}$ must first compute the partial key image, next select a random secret scalar $u_j$, then compute the commitments $c_k$, and finally must compute the value $s_{k,j} = u_j - c_k (H_s(a_j R) + b_j)$. 

Denote the coalition of user key pairs for $X_{\texttt{shared}}$ as $\left\{((a_{j}, b_{j}), (A_{j}, B_{j}))\right\}$. The coalition for $X_\texttt{shared}$ may use $\Pi_{\texttt{auth}}$ to share their $(H_s(a_{j} S) + b_{j})\cdot H_p(Q)$ and compute the key image $J = (\sum_j H_s(a_{j})S + b_{j}) H_p(Q)$. If some index, say $j$, corresponds to a user key pair $((a_j,b_j),(A_j,B_j))$ that is a $t_j$-of-$N_j$ public key, then the secrets $a_j$ and $b_j$ are not known by the coalition and so the $j^{th}$ share of the key image, $J_j$, must be collaboratively computed by at least $t_j$ coalition members for the shared key $((a_j,b_j),(A_j,B_j))$. Denote the coalition for this key as $\left\{((a_{j,i}, b_{j,i}), (A_{j,i}, B_{j,i}))\right\}_{i=1}^{N_j}$. Each member computes their share, $J_{j,i} = (H_s(a_{j,i} S) + b_{j,i})H_p(Q)$, this sub-coalition uses $\Pi_{\texttt{auth}}$ to compute $J_j = \sum_i J_{j,i}$, and the sub-coalition reports $J_j$ when prompted.

Similarly the random scalar $u_j$ is computed as a sum $u_j = \sum_i u_{j,i}$ using $\Pi$. Now any of these coalition members may compute the commitments $c_k$ and disseminate this to the rest of the coalition with $\Pi_{\texttt{auth}}$. At that point each member of the coalition may compute their individual $s_{k,j,i} = u_{j,i} - c_k x_{j,i}$ and the coalition may use $\Pi_{\texttt{auth}}$ to compute $s_{k,j} = \sum_i s_{k,j,i}$. In this way, sub-coalitions are simply handled recursively.

\begin{disc} 
If an OT-LTRM scheme is secure under the CIK model from Definition \ref{threshIndist} in Section \ref{subsec:CIK}, then it is not feasible for any PPT algorithm to check whether the keys used as input for $\texttt{Merge}$ are $1$-of-$1$, so modifying the straightforward implementation by banning composite coalition keys is not feasible. Recursion seems to be a natural design choice.
\end{disc}


\subsection{Coalition Indistinguishable Keys} \label{subsec:CIK}

Definition \ref{threshIndist} formalizes the idea that an adversary should not be able to determine information about the input of $\texttt{Merge}$ based on its output except with negligible probability. %Although we focus on restricted OT-LRTM schemes, and where thresholds are bounded by $N-1 \leq t \leq N$, this is a general definition that applies more broadly than the restricted case.  %Definition \ref{threshIndist} emphasizes the idea that the \textit{method of collaboratively fashioning keys} is not easily discernible by an adversary.

\begin{defn}[Coalition Indistinguishable Keys]\label{threshIndist} Let $\mathcal{A}$ be a PPT adversary. Let $N(-)$, $L(-)$ be polynomials.
\begin{enumerate}[(i)]
\item A set of user key pairs $S^* \subseteq \mathcal{K}_{\texttt{user}}$ with $\left|S\right|=N(\lambda)$ is generated where the $i^{th}$ key pair is $t_i$-of-$N_i$ public user key for some $2 \leq t_i \leq N_i \leq L(\lambda)$. The set of public keys $S = \left\{X_i \mid \exists (x_i, X_i) \in S^*\right\}$ is sent to $\mathcal{A}$.

\item $\mathcal{A}$ outputs $(\tau_0,C_0)$ where $C_0 \subseteq S$, $\tau_0 \in \mathbb{N}$, and $\tau_0 \leq \left|C_0\right|$.

\item A random pair $(\tau_1, C_1)$ is selected where $C_1 \subseteq S$, $\tau_1 \in \mathbb{N}$, $\tau_0 \neq \tau_1$, and $C_1 \neq C_0$. A random bit $b$ is selected. The key $X_{\tau_b,C_b} \leftarrow \texttt{Merge}(\tau_b, C_b)$ is sent to $\mathcal{A}$.

\item $\mathcal{A}$ outputs a bit $b^{\prime}$. This counts as a success if $b=b^{\prime}$.
\end{enumerate}
We say an OT-LRTM scheme has Coalition Indistinguishable Keys (CIK) if the adversary can succeed with probability only negligibly more than $1/2$.
\end{defn}

%We make some remarks on the straightforward $N$-of-$N$ implementation in Section \ref{naiveImplement}. 


\begin{disc}
Even taking the above modification into account, each $H_s(X_j, \mu_j)G$ must be communicated to the coalition. An adversary who can learn these points may simply check whether a given public key $X$ is the sum of some observed values of $H_s(X_j, \mu_j)G$, determining non-trivial information about coalition size. Hence, these points should be communicated with $\Pi$ if an OT-LRTM scheme is to satisfy Definition \ref{threshIndist}.
\end{disc}


 \begin{disc}
 We may be tempted to strengthen Definition \ref{threshIndist} to take into account corruption oracle access on the part of the adversary. Unfortunately this leads to certain problems with the security definition.   However, by using the hash-then-encrypt-then-authenticate method of computing shared public keys, without knowledge of the values of $\mu_j$, even if the adversary corrupts all the public keys in $S$, then $\mathcal{A}$ cannot successfully run $\texttt{Merge}$ for each value $1 \leq t \leq \left|S\right|$ to check the results by hand in comparison against the key $X_{t_b,C_b}$.  Thus, if the participating coalition members keep each $\mu_j$ and $\mu_j G$ secret, then even a very powerful adversary with oracle access for computing discrete logs will still be unable to discern whether some user key is a coalition key or not.
 \end{disc}
%In \cite{bender2006ring}, anonymity in ring signatures assumes at least two honest users in each ring, because if the adversary controls all keys except a single key controlled by an honest user, that adversary can certainly identify whether that honest user fashioned a signature!  %The adversary does not even need to know private information to violate coalition indistinguishability. %In fact, by merely knowing the CryptoNote public view key of a set $S$ of $N$ possible signers, an adversary may trivially check if some CryptoNote key pair $(A,B)$ is an $N$-of-$N$ key pair for the coalition $S$. 

%If granted corruption oracle access, any threshold subset of a coalition will also degrade coalition indistinguishability. To see why, assume the adversary is granted access to a corruption oracle and has corrupted a threshold subset of $S$. The adversary will then be able to construct valid signatures without the signing oracle, and will be able to conclude some information about the threshold, allowing for non-negligible success probability in the game of Definition \ref{threshIndist}. 

%Although we cannot strengthen Definition \ref{threshIndist} to take into account corruption by the adversary, 
\subsection{Signer Ambiguity}

In addition to coalition indistinguishability, we desire the ring signature property of \textit{signer ambiguity}. Variations of security models appear in \cite{bender2006ring}. 

Double spend protection in Monero relies on a one-time linkable ring signature scheme that is not signer ambiguous with respect to adversarially generated keys according to the definition presented in \cite{bender2006ring}. Indeed, in Monero, $\texttt{Link}$ simply checks if two key images $J_i$ are identical. In this way, the signer ambiguity game falls apart: $\mathcal{A}$ can obtain signature-tag pair $(\sigma_0, J_0)$ on $M_0$ using ring $R_0$ with $Q_{i_0} \in R_0$ and a pair $(\sigma_1, J_1)$ on $M_1$ using ring $R_1$ with $Q_{i_1} \in R_1$. Then, upon receipt of $(\sigma,J)$ in step (v), $\mathcal{A}$ can check if $J=J_0$ or $J=J_1$. The definition may be modified, however, to take key images into account.


Let $\mathcal{SO}(-,-,-,-)$ be a signing oracle that takes as input $(M,X,R,k)$ (a message, a destination public user key, a ring of public transaction keys, and an index $k$) and outputs a valid signature-tag pair $(\sigma, J) \leftarrow \texttt{Sign}(M,X,R,k,y)$ for some set $y$ of private user keys.

\begin{defn}{[Linkable Signer Ambiguity v. Adversarially Generated Keys]}\label{def:ambig} Let $N(-), L(-)$ be a positive polynomial. Let $\mathcal{A}$ be a PPT adversary. Let $\mathcal{A}$ have access to $\mathcal{SO}$. Consider the following game:
\begin{enumerate}[(i)]

\item A set of user key pairs $S^* \subseteq \mathcal{K}_{\texttt{user}}$ is selected with $\left|S^*\right| = N(\lambda)$. The public keys in $S^*$ are sent to $\mathcal{A}$.

\item $\mathcal{A}$ outputs a set of user key pairs $S \subseteq S^*$.

\item For each public user key $X_i \in S$, a public transaction key $Q^*_i \leftarrow \texttt{TxnKeyGen}(1^\lambda, X_i)$ is generated and the set $R^* := \left\{Q^*_i\right\}$ is generated, randomly permuted, and then sent to $\mathcal{A}$.

\item $\mathcal{A}$ selects a message $M$, a destination public user key $X \in \mathcal{K}_{\texttt{user}}$, a ring of transaction public keys $R=\left\{Q_1, \ldots, Q_L\right\} \subseteq \mathcal{K}_{\texttt{txn}}$, and two indices $i_0 \neq i_1$ such that $\left\{Q_{i_0}, Q_{i_1}\right\} \subseteq R^* \cap R$.

\item A random bit $b$ is chosen. The signature-tag pair $(\sigma,J) \leftarrow \mathcal{SO}(M,X,R,i_b)$ is sent to $\mathcal{A}$.

\item $\mathcal{A}$ outputs a bit $b^{\prime}$. The game counts as a success if (a) $b = b^{\prime}$ and (b) if $(M^{\prime},X^{\prime},R^{\prime},i)$ is a query from $\mathcal{A}$ to $\mathcal{SO}$, then the $i^{th}$ element of $R^{\prime}$ is not $Q_{i_0}$ or $Q_{i_1}$.

\end{enumerate}
We say the scheme is \textit{linkably signer ambiguous against adversarially generated keys} (LSA-AGK) if the probability that $\mathcal{A}$ succeeds is negligibly close to $1/2$ (with respect to $\lambda$).
\end{defn}

Definition \ref{def:ambig} essentially modifies the signer ambiguity game in \cite{bender2006ring} by adding requirements in step (vi) requiring that $\mathcal{A}$ see in step (v) either the key image for $Q_{i_0}$ or the key image for $Q_{i_1}$ for the first time.

\subsection{Unforgeability}
 

Unforgeability of any threshold signature scheme must take into account subthreshold corruption oracle access. Multisignatures must not be forgeable by a subthreshold collection of malicious coalition members, otherwise they have no utility as signatures, of course. A naive definition may be something like this:

\begin{defn}{[Prototype: Subthreshold Oracle Access]}\label{def:prot:subthresh}
Given a $S = \left\{X_1, \ldots, X_N\right\} \subseteq \mathcal{K}_{\texttt{user}}$ where each $X_i \in S$ is a $t_i$-of-$N_i$ public user key, we say that any PPT adversary $\mathcal{A}$ with access to an oracle $\mathcal{O}(-)$ has had \textit{subthreshold oracle access} to $S$ if, for any $X_i \in S$, at most $t_{i}-1$ coalition members for $X_i$ appear in the transcript between $\mathcal{A}$ and $\mathcal{O}(-)$.
\end{defn}

However, since $\texttt{Merge}$ allows inputs of arbitrary (possibly threshold) user keys, this definition is insufficient. %In fact, we must define the \textit{depth} of public keys to handle this issue appropriately. We say a user key pair resulting from $\texttt{UserKeyGen}$ has \texttt{depth} $0$. We define the depth of a user key $X_{\texttt{shared}} \leftarrow \texttt{Merge}(t,C)$ as $\texttt{depth}(X_{\texttt{shared}}) = \max\left\{\texttt{depth}(Y) \mid Y \in C\right\} + 1$. 
For notational convenience, we call $\mathcal{M}(-)$ an oracle that inverts $\texttt{Merge}$ by taking as input a public $t$-of-$N$ key $X$ and producing as output $(t,C)$, the threshold $t$ and coalition $C$ such that $X = \texttt{Merge}(t,C)$. For any subset $S \subseteq \mathcal{K}_{\texttt{user}}$, define $\mathcal{M}(S) = \cup_{Y \in S} \mathcal{M}(Y)$. This provides the iterative definition $\mathcal{M}^{i+1}(S) = \cup_{Y \in S}\mathcal{M}^{i}(Y)$. Define $\mathcal{M}^{\leftarrow}(Y) := \cup_i \mathcal{M}^i(Y)$.

\begin{defn}{[Subthreshold Oracle Access]}\label{def:prot:subthresh}
Let $S$ be a set of public user keys $S = \left\{X_1, \ldots, X_N\right\}$ where each $X_i$ is a $t_i$-of-$N_i$ public user key. We say that any PPT adversary $\mathcal{A}$ with access to an oracle $\mathcal{O}(-)$ has had \textit{subthreshold oracle access} to $S$ if, for any public user key $Y \in \mathcal{M}^{\leftarrow}(S)$, if $Y$ is a $t_Y$-of-$N_Y$ shared public user key, then at most $t_{Y}-1$ coalition members from $\mathcal{M}(Y)$ appear in the transcript between $\mathcal{A}$ and $\mathcal{O}(-)$.
\end{defn}


% 

%In this definition, we grant $\mathcal{A}$ access to $\mathcal{SO}$ as before but also $\mathcal{CO}_{\texttt{user}}(-)$, a user key corruption oracle. $\mathcal{CO}_{\texttt{user}}(-)$ accepts as input a public user key and produces as output the associated private user key. 

Also for notational convenience, we call $\mathcal{T}(-)$ an oracle that inverts $\texttt{TxnKeyGen}$ by taking as input a public transaction key $Q_X$ and produces as output the user key $X$.



%Every signature scheme is only as useful as its unforgeability properties in the face of an adversary with corruption and signing oracle access. Previous security definitions as in \cite{bender2006ring} do not take into account threshold multisignatures. Indeed, an attacker with at most subthreshold corruption oracle access to $R$ should also be unable to forge a signature:



\begin{defn}{[Existential Unforgeability v. Adaptive Chosen Message and Subthreshold Insider Corruption]}\label{steuf} Let $\mathcal{A}$ be a PPT adversary and $L(-)$ be polynomials. $\mathcal{A}$ is given access to a signing oracle $\mathcal{SO}$, a corruption oracle $\mathcal{CO}_{\texttt{user}}$. Consider the following game:

\begin{enumerate}[(i)]
\item A set of user key pairs $S^* \subseteq  \mathcal{K}_{\texttt{user}}$ is selected with $\left|S^*\right| = N(\lambda)$. The public keys in $S^*$ are sent to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a set of user key pairs $S \subseteq S^*$.
\item For each public user key $X_i \in S$, a public transaction key $Q_i^* \leftarrow \texttt{TxnKeyGen}(1^\lambda, X_i)$ is generated and the set $R^* := \left\{Q_i^*\right\}$ is constructed, randomly permuted, and then sent to $\mathcal{A}$.
\item $\mathcal{A}$ outputs a message $M$, a destination public user key $X \in \mathcal{K}_{\texttt{user}}$, ring $R \subseteq \mathcal{K}_{\texttt{txn}}$ of public transaction keys, and a signature $\sigma$. The game counts as a success if 
\begin{enumerate}[(a)]
\item $R \subseteq R^*$,
\item $\texttt{VER}(M,R,\sigma)=1$,
\item for each index $k$ in $R$, $(M,X,R,k)$ does not appear in the queries between $\mathcal{A}$ and $\mathcal{SO}$
\item for each $Q_k \in R$, $\mathcal{CO}_{\texttt{user}}$ is not queried with the public user key $\mathcal{T}(Q_k)$, and
\item $\mathcal{A}$ has had subthreshold $\mathcal{CO}_{\texttt{user}}$ access to the set $\left\{\mathcal{T}(Q_k) \mid Q_k \in R\right\}$.

\end{enumerate}
\end{enumerate}
A scheme in which an adversary is only negligibly likely to succeed is said to be \textit{existentially unforgeable with respect to adaptive chosen message attacks and subthreshold insider corruption} (or \textit{st-EUF} for subthreshold existentially unforgeable).
\end{defn}





\section{Proposed Implementation}\label{sec:implement}

We provide an implementation of a restricted OT-LRTM scheme allowing only for $N-1 \leq t \leq N$ in the spirit of the original CryptoNote methodology. User secret keys and public keys are both ordered pairs of keys, i.e.\ private key $(a,b)$ and public key $(A,B)$. Following terminology from \cite{van2013cryptonote}, we refer to $(a,A)$ as the \textit{view keypair} and $(b,B)$ and the \textit{spend keypair}.  We let $\Pi = (\texttt{Gen}^*,\texttt{Enc}^*, \texttt{Auth}^*, \texttt{Ver}^*, \texttt{Dec}^*)$ be a secure encrypt-then-authenticate scheme (where $\Pi_{\texttt{enc}} = (\texttt{Gen}^*,\texttt{Enc}^*, \texttt{Dec}^*)$ is a secure encryption sub-scheme and $\Pi_{\texttt{auth}} = (\texttt{Gen}^*,\texttt{Auth}^*, \texttt{Ver}^*)$ is a secure message authentication sub-scheme). %We use both of these schemes for computing sums, so the encryption and decryption algorithms may be taken as an homomorphic encryption scheme.

\texttt{UserKeyGen} generates the secret key $z=(a,b)$ by selecting $a,b$ from an i.i.d.\ uniform distribution on $\mathbb{Z}_q$, and computing $Z=(A,B)$ with $A:=aG$ and $B:=bG$. \texttt{UserKeyGen} then outputs $(z,Z)$.

\texttt{Merge} takes as input a threshold $t$ and a set of key pairs $C=\left\{(z_1,Z_1), \ldots, (z_n,Z_N)\right\}$  such that $2 \leq N-1 \leq t \leq N$ where each $Z_i = (A_i,B_i)$. If $N=1$, $\texttt{Merge}$ outputs $Z_1$.  Otherwise:
\begin{enumerate}[(1)]
\item Each member of the coalition selects constants $\mu_i, \gamma_i$ for the multisig address. 
\item Each member derives a partial secret keypair $(a^*_i, b^*_i)$ where $a^*_i = H_s(a_i, \mu_i)$ and $b^*_i = H_s(b_i, \gamma_i)$ and computes their associated public points $A^*_i=a^*_i G$, $B^*_i = b^*_i G$. 
%\item Each member uses $\Pi_{\texttt{auth}}$ to send $(A^*_i, B^*_i)$ to the coalition.
\item If $t=N$, then the coalition uses $\Pi$ to collaboratively compute the shared secret view key $a^* = \sum_i a^*_i$\footnote{Note that although secret information is about $a_i$ not being directly shared with the coalition, the result of the computation is, in fact, a secret key, $a^*$.}, uses $\Pi_{\texttt{auth}}$ to collaboratively compute the shared public spend key $B^* = \sum_{i=1}^{N} B^*_i$. If $t=N-1$, then %, and then uses $\Pi$ to collaboratively compute the key image $J = \sum_{i=1}^{N} b^*_i H_p(B^*)$.:
\begin{enumerate}[(a)]
\item For each $i,j$, a partial shared secret view key $\alpha_{i,j} := H_s(a^*_iA^*_i)$ and a partial shared secret spend key $\beta_{i,j} := H_s(b^*_iB^*_i)$ is computed by either participant $i$ or $j$.
\item Set $N^* := \frac{N(N+1)}{2}$, $S^* := \left\{((\alpha_{i,j},\beta_{i,j}), (\alpha_{i,j}G, \beta_{i,j}G))\right\}_{1 \leq i < j \leq N}$, and run $\texttt{Merge}(N^*, S^*)$.
\end{enumerate}
\item Every coalition member now knows the shared secret view key $a^*$ and the shared public spend key $B^*$.

\end{enumerate}

\texttt{TxnKeyGen} takes as input a destination user public key $(A,B)$, selects a random scalar $r$, computes $R=rG$ and $P = H_s(rA)G + B$, and outputs $(R,P)$.

\texttt{ImageGen} takes as input a set of private user keys $y = \left\{(a_1, b_1), \ldots, (a_N, b_N)\right\}$ and a public transaction key $(R,P)$. For each $i=1,\ldots,N$, the $i^{th}$ member of $y$ computes partial key image $J_i = (H_s(a_i R)+ b_i)H_p(R,P)$. The participating members use $\Pi_\texttt{auth}$ to compute $J = \sum_i J_i$.

\texttt{Sign} takes as input a message $M$, a destination public user key $(A_{\texttt{dest}}, B_{\texttt{dest}})$, a set of public transaction keys $\left\{(R_1, P_1), \ldots, (R_L, P_L)\right\}$, a secret index $1 \leq k \leq L$, and a set of $t$ private keys $y=\left\{(a^*_i, b^*_i)\right\}_{i=1}^{t}$.
\begin{enumerate}[(1)]
\item The points $(R^*, P^*) \leftarrow \texttt{TxnKeyGen}(1^\lambda, (A_{\texttt{dest}}, B_{\texttt{dest}}))$ are computed.
\item The owners of $y=\left\{(a^*_i, b^*_i)\right\}$ (the \textit{signatories}) run $J \leftarrow \texttt{ImageGen}(1^\lambda, (R_k, P_k), y)$
\item A set $\left\{s_{k+1}, s_{k+2}, \ldots, s_{k-1}\right\}$ of i.i.d.\ observations of uniform random variables are generated by the coalition and shared among the coalition using $\Pi_{\texttt{auth}}$.\footnote{We recommend that a coordinating user randomly selects these using a cryptographic random number generator; only the user coordinating the signature needs these values.}
\item For each $j$, the $j^{th}$ signatory selects a random scalar $u_{j}$, computes $H_i:=H_{p}(B_i)$ for each index $1 \leq i \leq L$, and computes the points $u_jG$ and $u_jH_{k}$. The coalition uses $\Pi_{\texttt{auth}}$ to collaboratively compute $u_{k}G := \sum_j u_j G$ and $u_k H_k:= \sum_j u_j H_{k}$.

\item Some threshold member computes 
\begin{align*}
    c_{k+1} =& H_{p}(m, u_{k} G, u_{k} H_{k})\text{ and }\\
    c_{i+1} =& H_{p}(m, s_i G + c_i B_i, s_i H_{i} + c_i J)\text{ for }i=k+1, k+2, \ldots, k-1.
\end{align*}
\item The threshold member from the previous step uses $\Pi_{\texttt{auth}}$ to send $c_{k}$ to all other signers with authentication. These signers may check that their received $c_k$ matches their expected computations.
\item If $t=N$, each signatory computes their personal $s_{k,j} := u_j - c_{k} b_j^*$. If $t=N-1$, each signatory computes $s_{k,j} = u_j - c_{k} \sum_{i=1}^{L}z_{i,j}$. The coalition uses $\Pi_{\texttt{auth}}$ to collaboratively compute $s_k = \sum_j s_{k,j}$ and construct the signature $\sigma = (c_1, s_1, s_2, \ldots, s_L)$.
\item Any signatory may now publish the signature-tag pair $(\sigma, J)$ where $\sigma=(c_1, s_1, \ldots, s_N)$ together with the public transaction key $(R^*, P^*)$.
 \end{enumerate}
 
 
\begin{disc} The resulting signature takes the same form as LSAG signatures as in \cite{liu2004linkable}. Modifying the above to appropriately to take into account key vectors provides the generalization to MLSAG signatures. Thus the verification algorithm for these signatures is identical to the verification algorithm for usual MLSAG signatures and we omit its description. Similarly, $\texttt{Link}$ merely outputs a bit signifying whether two key images are identical, so we don't describe it further either.

\end{disc}


 
 \begin{disc}
 Each $u_j$ is kept secret from the other users and is generated randomly when the signature process begins. Certainly if $u_j$ is revealed to another signatory, since the values of $s_j$ and $c_i$ are communicated in with authentication but not encryption, revealing the value $u_j - c_{i^{\prime}} x_j$ can lead an observer to deduce $x_j$. Encryption does not solve the problem if threshold members are untrustworthy.
 
 
 Similarly, if some value of $u_j$ is re-used twice with the same private key, an observer can deduce the private key. Indeed, assuming we are using a hash function resistant to second pre-image attacks, the commitments from two signature processes $c_{i^{\prime}}, c_{i^{\prime}}^*$ are unequal except with negligible probability even if the other threshold members are colluding. Hence since $s_{i^{\prime},j} = u_j - c_{i^{\prime}} x_{j}$ and $s_{i^{\prime},j}^* = u_j - c_{i^{\prime}}^* x_{j}$, an observer may solve for the private key $x_j$. Don't re-use values of $u_j$, keep them secret, generate them randomly.
 
 \end{disc}
 
 \begin{disc}  Note that users in $(N-1)$-of-$N$ processes are prompted to select constants $\mu, \gamma$ multiple times for multiple sets of keys. If our hash function $H_s(-)$ is suitably secure, the lazy user can re-use the same constants $\mu$ and $\gamma$ without concern; nevertheless, it is recommended that users do not re-use constants in $\texttt{Merge}$. 
 \end{disc}
 
 
 \section{Security}
 
 %Note that for our restricted RTM described in Section \ref{sec:implement} only accepts thresholds $t$ such that $2 \leq N-1 \leq t \leq N$ and only merges keys of depth zero. 
 
 Recall the critical fact proven in \cite{scozzafava1993uniform} that the sum of a uniform random variable with any indepenent random variable in $\mathbb{Z}/m\mathbb{Z}$ results in a uniform random variable (and conversely when $m$ is prime). Hence, no PPT algorithm will be able to distinguish between a uniform random variable $U$ and a sum of uniform random variables, $\sum_i U_i$. 
 
 Assume $H_s$, $H_p$ in the OT-LRTM implementation from Section \ref{sec:implement} are cryptographic hash functions under the random oracle model whose outputs are statistically indistinguishable from a uniform distribution except with non-negligible probability, and whose outputs are independent of one another. Assume $\texttt{UserKeyGen}$ produces keys from a distribution  that is statistically indistinguishable from a uniform distribution. 
 


\begin{theorem}
The restricted OT-LRTM implementation from Section \ref{sec:implement} is CIK.
\end{theorem}
\begin{proof}
Either the key pair $X_b = (A,B)$ received by $\mathcal{A}$ in step (iii) of Definition \ref{threshIndist} is $N$-of-$N$ for some $N \geq 2$, $(N-1)$-of-$N$ for some $N \geq 3$, or a mere $1$-of-$1$ user key. Of course, $(N-1)$-of-$N$ key pairs are $N^*$-of-$N^*$ key pairs. Thus, we really only need to deal with two cases: an $N$-of-$N$ key pair with $N > 1$ or a $1$-of-$1$ key pair.
  
If $(A,B)$ is an $N$-of-$N$ key pair, then $A^* = \sum_{i} H_s(a_i, \mu_i) G$ and $B^* = \sum_i H_s(b_i, \gamma_i) G$. Since $H_s$ is a random oracle, any one of its outputs is uniformly random, and so any sum of its outputs is uniformly random \cite{scozzafava1993uniform}, so no PPT adversary may determine the number of signatories. On the other hand, if $(A,B)$ is a $1$-of-$1$ key pair, then $A$ and $B$ are each independent uniform random variables from $\texttt{UserKeyGen}$, so no PPT algorithm can determine whether $A$ or $B$ is a sum or not.
  
\end{proof}
  
  \begin{theorem} The OT-LRTM implementation from Section \ref{sec:implement} is LSA-AGK.
  \end{theorem}
  \begin{proof}
  $\mathcal{A}$ selects transaction public keys as ring members $(R_0, P_0) = (r_0 G, H_s(r_0 A_0)G + B_0)$ and $(R_1, P_1) = (r_1 G, H_s(r_1 A_1)G + B_1)$, a message $M$, a destination key pair $(A_{\texttt{dest}}, B_{\texttt{dest}})$ and receives a signature-tag pair  $(\sigma, J_b)$.  $\mathcal{A}$ can compute $H_p(R_b, P_b)$ for each $b \in \left\{0,1\right\}$, but without knowing the secrets $a_b, b_b$, computing $J_b = (H_s(a_b R_b) + b_b)H_p(R_b, P_b)$ for either $b$ is infeasible for PPT $\mathcal{A}$. Moreover, $\sigma$ has the same security properties as in \cite{liu2004linkable}.\footnote{WORK ON THIS}
  \end{proof}
 
 \begin{theorem} The OT-LRTM implementation from Section \ref{sec:implement} is st-EUF.
 \end{theorem}
 \begin{proof} 
 Assume $\mathcal{A}$ is a PPT adversary that can succeed at the game in Definition \ref{} with non-negligible advantage. The adversary has sub-threshold access to the ring, $\mathcal{A}$ cannot execute $\texttt{Sign}$ fairly and must attempt a forgery by generating additional random numbers. In this case, the adversary is merely attempting to forge a usual LSAG signature, and the security proof reduces to the one presented by \cite{liu2004linkable}.
 
 %We use the rewind-on-success approach presented in \cite{liu2004linkable}.  Assume a reduction master $\mathcal{M}$ simulates adversary $\mathcal{A}$ who can succeed at the game presented in Definition \ref{steuf} with non-negligible probability, bounded below by $1/Q_1(\lambda)$ for some polynomial $Q_1(-)$. Let $q_{H}$ be the number of queries $\mathcal{A}$ makes to the $H_s(-)$ or $H_p(-)$, $q_C$ be the number of queries $\mathcal{A}$ makes to the corruption oracle, let $q_S$ be the number of queries $\mathcal{A}$ makes to the signing oracle.
 
 %Then $\mathcal{A}$ produces a signature $\sigma$, a message $M$, and a set $R \subseteq S$ such that $\texttt{VER}(M,R,\sigma) = 1$. Denote the number of public keys $\left|R\right|$. 
 
 %We first show that, except with negligible probability, $\mathcal{A}$ must have included all verification queries to $H_p$ of the form 
 %\[c_{i+1} = H_p(m, s_i G + c_i B_i, s_i H_i + c_i J)\]
 %among their $q_H$ queries. To pass this verification, $\left|R\right|$ solutions to these equations must be presented. Let $E$ be the event that all $\left|R\right|$ of these queries are included in the $q_H$ queries made by $\mathcal{A}$, and $\overline{E}$ the set complement. In the event $\overline{E}$, $\mathcal{M}$ needs to generate additional random numbers in order to verify the forgery; but $\mathcal{A}$ did not make oracle queries for these random numbers, so $\mathcal{A}$ could only guess the outcomes of those queries. Consequently, the probability that $c_1$ matches the required validation is at most $1/(q - q_H - n q_S)$. Since this is negligible, the probability of the intersection of $E$ with a forgery by $\mathcal{A}$ is non-negligible. Note that this result is independent of corruption oracle and signing oracle access, since the adversary cannot invert $H_p(-)$ except with negligible probability.
 
 %Thus, in any transcript where $\mathcal{A}$ computes a successful forgery there exists an oracle query of the form $H_p(m, s_i G + c_i B_i, s_i H_i + c_i J)$.
 
 %Moreover, $\mathcal{A}$ has not directly corrupted any keys in $R$, $\mathcal{A}$ has at most subthreshold corruption oracle access to any threshold keys in $R$, and $\mathcal{A}$ has not send $(k,M,R)$ in a query to $\mathcal{SO}$. 
 \end{proof}

%If we assume all threshold members are honest, the scheme reduces to the usual LSAG signature as in \cite{liu2004linkable}. However, this is an undesirable assumption for applications in cryptocurrency. Definition \ref{defn:unf} is inadequate in the threshold setting because, if some $B_i$ is a $t_i$-of-$n_i$ shared public key in the ring, the adversary may query the oracle $\mathcal{SO}$ to sign messages on behalf of some of the $n_i$ members sharing the public key $B_i$ without violating the conditions of Definition \ref{defn:unf}. Do to this, we consider Definition \ref{defn:unf2} to describe adaptive chosen message attacks where insiders. 

%Since we may regard any $(n-1)$-of-$n$ instantiation of the above scheme as an $n^*$-of-$n^*$ instantiation, it is sufficient to prove that any $n$-of-$n$ instantiation is secure. The $1$-of-$1$ instantiation is merely the LSAG signature from \cite{liu2004linkable}; in this setting, Definitions \ref{defn:unf} and \ref{defn:unf2} coincide, so we only must concern ourselves with $n$-of-$n$ instantiations with $n \geq 2$.

%The strength of the security proof from \cite{liu2004linkable} rests on novel rewind-on-success simulations. Rewind simulations were first presented as the forking lemma in \cite{pointcheval1996security} and the heavy row lemma in \cite{ohta1998concrete}; rewind-on-success simulations are first presented in \cite{liu2004linkable}. With a master PPT $\mathcal{M}$ invoking a PPT adversary $\mathcal{A}$ to obtain a transcript $\mathcal{T}$ in an attack game on some scheme $\Pi$ may, the rewind-on-success simulation will, upon finding a success in $\mathcal{T}$,  rewind $\mathcal{T}$ to some point, header $h$ and ``begin again'' to seek an additional success. Resimulating $\mathcal{A}$ with new random data, $\mathcal{M}$ generates a new transcript $\mathcal{T}^*$ where $\mathcal{T}$ and $\mathcal{T}^*$ are identical up to (and including) header $h$. It is established in \protect{\cite[Lem E.1]{liu2004linkable}} that the probabilities of success of $\mathcal{T}$ and $\mathcal{T}^*$ are identical (although this says nothing of their independence). Thus an attacker who can find one success with non-negligible probability can find any finite number they desire using rewind-on-success with non-negligible probability.

%Thus, if the adversary can successfully compute one forged signature on a message with non-negligible probability, say $\sigma = (c_1, s_1, \ldots, s_N, J)$, then that adversary can rewind and compute a second forged signature with the same key image but different random values $s_i^*$, say $\sigma^* = (c_1^*, s_1^*, \ldots, s_N^*, J)$, also with non-negligible probability. In checking that these forgeries satisfy verification, the adversary must compute the commitments in the LSAG signature, and hence must query some hash function $H$ at least once per commitment. So the adversary must make as many queries to $H$ as there are ring members, $L$, each of the form $H(J,m, sG + cB, sH(B) + cJ)$, where $B$ is a public key in the ring and $J$ is the key image associated to the signature. In computing the first forgery, the adversary must compute some first commitment $H(m,J, uG, vG^{\prime}) = H(m,J, sG + cB, sH(B) + cJ)$, where $u$, $v$, and the base point $G^{\prime}$ are each unknown before rewinding. After rewinding and computing a second forgery, the adversary has the system of equations
%\begin{align*}
    %uG =& sG + cB\\
    %uG =& s^*G + c^*B\\
    %vG^{\prime} =& sH(B) + cJ\\
    %vG^{\prime} =& s^*H(B) + c^*J\\
%\end{align*}
%The adversary can then compute the secret key $b = \frac{s-s^*}{c^*-c}$, solving the discrete log problem $B = bG$.

%This proof extends directly to MLSAG signatures; this was claimed in \cite{noether2016ring} but the proof therein contained a mistake, which we correct here:
%\todo{Shen's security theorem and corrected proof}
%\begin{thm}
%*
%\end{thm}
 

%The signatories must make several joint decisions in the process described under Section \ref{sec:implement}. We are vague in their description because the implementation of these steps can be done in many ways. 

%For example, in Step 3, the signatories decide upon a ring and a secret index to store their public keys. This may be done by merely having some member do it randomly (introducing a sort of Byzantine General problem), or using some deterministic (but seemingly random) method chosen ahead of time in meatspace based on the input message. The secret index should appear to be uniformly random, regardless of method employed. Note that one of the signatories can publicly communicate a sort of encryption of the secret index without harm by merely publishing the ring of public keys $Q$; other signatories know their own public keys, so they can inspect the ring and determine the secret index without any further information from the first signatory and without observers being able to discern which index is the threshold key.

%Also in Step 3, the signatories decide on the values of $s_i$ randomly. One method is for each signatory to compute their own $s_{i,j}$ and computing the shared sums $s_i = \sum_j s_{i,j}$. This requires a lot of interaction; another method is to simply let one threshold member do it and communicate the values to the group with authentication. Note that the values $s_i$ are eventually made public in the signature and there is no harm in sharing these values without encryption. Similarly, in step 8, we compute the sum $\sum_j s_{i^{\prime},j}$; since each user keeps their $u_j$ secret, they can reveal their $u_j - c_{i^{\prime}} b_j^*$ or $u_j - c_{i^{\prime}} \sum_{i=1}^{L} z_{i,j}$ without risking their private keys, so there is no harm in sharing these values without encryption.

%To communicate a message with authentication, we use the HMAC scheme: for the $j^{th}$ threshold member to communicate a message $M$ to the $i^{th}$ threshold member, a shared secret $t_{i,j}$ is computed and $(M, \texttt{HMAC}(t_{i,j}, M))$ is sent. For a CCA-secure encrypt-and-authenticate scheme \cite{katzAndLindell}, two users generate two shared secrets $t_{i,j}$, $t^*_{i,j}$. The sending user computes the ciphertext $C = \texttt{Enc}(t_{i,j}, M)$ and the authentication codes $\tau = \texttt{HMAC}(t^*_{i,j}, C)$ and sends $(C,\tau)$ to the receiver. If a receiver sees some $(C,\tau)$, they can check if $\tau$ is a valid HMAC on $C$ for any of their shared secrets. If so, they can decrypt $C$ with the other shared secret.




%\begin{comment}


%Additional properties are often required in application, such as \textit{linkability}: an adversary can feasibly identify whether two signatures have been fashioned by some common private keys. In the case of usual ring signatures, this is an obvious question: if the true signer of two signatures is the same, output $1$, otherwise $0$. Linkability schemes can be de-anonymizing if the process reveals more than just a bit, like the associated user public key (or worse, the user secret key). Unfortunately, in the case of $t$-of-$n$ threshold signatures, the property of linkability comes in several flavors.


%A brief notational consideration: for some signature $\sigma$ generated by following the protocol honestly, denote $P^*_\sigma$ as the ring of public signing keys associated with $\sigma$, denote $(sk^*_\sigma, pk^*_\sigma)$ as the signing keypair of the signatory for $\sigma$. For such a signature, there must have existed a $t$-of-$n$ configuration of users (recall this is a collection of user secret keys), which comes equipped with a set of user public keys $P_\sigma$, and a subset of the associated user secret keys $S_\sigma$. Denote the set of public keys associated with the user secret keys in $S_\sigma$ as $P(S_\sigma)$.

%A t-of-n threshold ring signature scheme can be made into a linkable $t$-of-$n$ threshold ring signature if it comes equipped with an PPT algorithm \texttt{Lnk} that outputs a bit if two input signatures are linked. Implementation of \texttt{Lnk} depends critically on the application. If linkability is defined such that we only detect when \textit{exact same} $t$-of-$n$ configuration of users signed two signatures, then it is possible that a group of $n=t+1$ users conspire to fashion $t+1$ different $t$-of-$n$ threshold ring signatures, each with a unique $t$-of-$n$ configuration. Hence, these signers are able to fashion as many different $t$-of-$n$ signatures as they have conspirators before linkability reveals their behavior. On the other hand, by requiring all user keys from \texttt{GenUserKey} be one-time keypairs generated in a Diffie-Hellman exchange, this forces all of our signatures to be one-time signatures and the problem is resolved.

%On the other end of the spectrum, presume linkability is defined such that two signatures are linked if \textit{at least one} user private key is used in common between two signatures. Then each private key can participate in at most one signing, regardless of the size of coalition of users $n$ or threshold $t$, before use of their private key will lead to linkage. This may be undesirable for many applications, but the appeal for use in e-cash schemes is obvious. 

%We use the following terminology. If an adversary can feasibly compute some nontrivial function of the sets $P(S_{\sigma_1})$ and $P(S_{\sigma_2})$, we say the scheme is \textit{leaky}.  If an attacker can feasibly determine whether $P(S_{\sigma_1}) = P(S_{\sigma_2})$, then we say that the scheme is \textit{linkable}. If an attacker can feasibly determine whether $P(S_{\sigma_1}) \cap P(S_{\sigma_2}) = \emptyset$, then we say that the scheme is \textit{individually linkable}.   Certainly every linkable scheme and every individually linkable scheme is leaky. If an adversary can feasibly compute some nontrivial function of the sets $S_{\sigma_1}$ and $S_{\sigma_2}$, we say the scheme is \textit{very leaky}. Note that every very leaky scheme is leaky. We attain a hierarchy induced by both linkability and leakage.


%Recall that a usual ring signature is a $1$-of-$1$ threshold ring signature. Thus, a linkable ring signature is a linkable $1$-of-$1$ threshold ring signature. In particular, given two signatures, an adversary can feasibly determine whether the public key of the signer of both signatures is the same. It's clear that in this scenario, the notion of linkability and the notion of individual linkability coincide.


%For our purposes, we use a \texttt{Lnk} algorithm that takes as input a $t_1$-of-$n_1$ signature $\sigma_1$ on message $M_1$ with possible signing public keys $P^*_1$, a $t_2$-of-$n_2$ signature $\sigma_2$ on message $M_2$ with possible signing public keys $P^*_2$. The algorithm outputs a bit if any secret key used to generate $\sigma_1$ was also used to generate $\sigma_2$.

%In a linkable $t$-of-$n$ threshold ring signature with, say $L$ ring members, each ring member consists of some $t$-of-$n$ threshold configuration of user keys. In this way, each signature implicates $L$ threshold configurations, each with $t$ users, so each signature implicates $tL$ users. If any particular $t$-of-$n$ threshold configuration


\section{Further Analysis}

\subsection{Efficiency and comparisons}

The signatures resulting from the OT-LRTM scheme are indistinguishable from MLSAG signatures, so space complexity and verification time complexity of the OT-LRTM scheme is identical to that of MLSAGs. Due to the use of $\Pi$ and several (possibly recursive) rounds of communication between coalition participants, efficiency of signatures is greatly reduced. 

For a coalition consisting of $1$-of-$1$ keys, $\texttt{Merge}$ takes one round of communication inside the coalition with $\Pi$, $\texttt{ImageGen}$ takes one round of communication inside the coalition with $\Pi_{\texttt{auth}}$, $\texttt{Sign}$ takes three distinct rounds of communication with $\Pi_{\texttt{auth}}$ and calls $\texttt{TxnKeyGen}$ and $\texttt{ImageGen}$ each once. In total, this amounts to five rounds of communication inside the coalition per signature. For a coalition containing shared user keys for sub-coalitions, the rounds of communication in $\texttt{Sign}$ must also take place inside each sub-coalition (and sub-sub-coalition, and so on).

In total, if we define the \textit{depth} of $1$-of-$1$ public user key as depth $0$, and the \textit{depth} of any $t$-of-$N$ public user key $X$ with coalition $C$ as $\max\left\{\texttt{depth}(X) \mid X \in C\right\}+1$. Then for a signature with a coalition of depth $D$ where each coalition has at most $N$ members, we require at most $2 + 3\cdot D^N$ rounds of communication to fashion a signature.

\subsection{Elaborations}


 %A stronger version of Definition \ref{threshIndist} is available by granting the adversary access to a signing oracle, providing coalition indistinguishable keys and signatures against chosen message attacks (CIKS-CMA), which guarantees that not only are \textit{keys} coalition-indistinguishable, but also signatures, even if the adversary can obtain arbitrary signatures.
 




We speculate that modifications to the CryptoNote-styled constructions of key images may allow for stronger notions of signer ambiguity in the future without sacrificing robustness against double-spend attacks. For example, by taking key images as homomorphic commitments, two commitments may be linked if their difference is a commitment to zero without revealing their masks. This is beyond the scope of this document.

Can the notion of CIK be expanded to CIKS so as to include signatures and chosen messages? With an LRTM, this expansion is nontrivial but straightforward. With an OT-LRTM, this becomes a delicate generalization due to the one-time transaction keys.



\emph{Special Thanks}: We would like to issue a special thanks to the members of the Monero community who used the GetMonero.org Forum Funding System to support the Monero Research Lab. Readers may also regard this as a statement of conflict of interest, since our funding is denominated in Monero and provided directly by members of the Monero community by the Forum Funding System.

\medskip{}

\bibliographystyle{plain}
\bibliography{biblio.bib}

\end{document}